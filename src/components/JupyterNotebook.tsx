import { createElement, ReactNode, useEffect, useState } from "react";
import CustomMarkdown from "./CustomMarkdown";

function Code({ language, children }: { language: string; children: string }) {
  return (
    // :))
    <CustomMarkdown>
      {"```" + language + "\n" + children + "\n```"}
    </CustomMarkdown>
    // <SyntaxHighlighter
    //   children={children.replace(/\n$/, "")}
    //   style={theme}
    //   language={language}
    //   PreTag="div"
    // />
  );
}

export function JupyterCell({ cell }: { cell: Cell }) {
  if (cell.cell_type === "markdown") {
    return <CustomMarkdown>{cell.source?.join("\n") || ""}</CustomMarkdown>;
  } else if (cell.cell_type === "code") {
    const value = (cell.input || cell.source)?.join("\n") || "";

    const outputs = cell.outputs as any;

    let output: ReactNode = null;

    if (Array.isArray(outputs) && outputs.length === 1) {
      if ("text" in outputs[0]) {
        output = <pre>{outputs[0].text.join("\n")}</pre>;
      } else if (outputs[0].data) {
        const data = outputs[0].data;
        if (data.hasOwnProperty("text/html")) {
          output = (
            <div dangerouslySetInnerHTML={{ __html: data["text/html"] }} />
          );
        } else if (data.hasOwnProperty("application/json")) {
          output = (
            <pre>{JSON.stringify(data["application/json"], null, 2)}</pre>
          );
        } else if (data.hasOwnProperty("image/png")) {
          output = (
            <img src={"data:image/png;base64," + data["image/png"]} alt="" />
          );
        } else if (data.hasOwnProperty("text/plain")) {
          output = <pre>{data["text/plain"].join("\n")}</pre>;
        }
      }
    }

    return value ? (
      <>
        <Code language={cell.language || "python"}>{value}</Code>
        <pre>{output}</pre>
      </>
    ) : null;
  } else if (cell.cell_type === "heading") {
    return createElement("h" + cell.level, {}, cell.source?.join("\n"));
  } else {
    return <span>Unsupported cell type</span>;
  }
}

function useJupyterNotebook(url: string) {
  const [notebook, setNotebook] = useState<JupyterNotebookType | null>(null);

  useEffect(() => {
    async function run() {
      const response = await fetch(url);
      const json = await response.json();
      setNotebook(json);
    }

    run();
  }, [url]);

  return notebook;
}

export function JupyterNotebookEmbedded({ url }: { url: string }) {
  const notebook = useJupyterNotebook(url);

  if (!notebook) {
    return <span>Loading...</span>;
  }

  return <JupyterNotebook notebook={notebook} />;
}

export default function JupyterNotebook({
  notebook,
}: {
  notebook: JupyterNotebookType;
}) {
  // return <JupyterViewer rawIpynb={notebook as any} />;

  // const name = notebook.metadata.name;
  const items = [];
  // @ts-ignore
  for (const worksheet of notebook.worksheets || [notebook]) {
    for (let i = 0; i < worksheet.cells.length; i++) {
      const cell = worksheet.cells[i];
      items.push(<JupyterCell cell={cell} key={i} />);
    }
  }
  return (
    <div style={{ display: "flex", flexDirection: "column" }}>{items}</div>
  );
}

// Generated by https://quicktype.io

export interface JupyterNotebookType {
  metadata: JupyterNotebookMetadata;
  nbformat: number;
  nbformat_minor: number;
  worksheets: Worksheet[];
}

export interface JupyterNotebookMetadata {
  name: string;
}

export interface Worksheet {
  cells: Cell[];
  metadata: CellMetadata;
}

export interface Cell {
  cell_type: CellType;
  level?: number;
  metadata: CellMetadata;
  source?: string[];
  collapsed?: boolean;
  input?: string[];
  language?: string;
  outputs?: Output[];
  prompt_number?: number;
}

export enum CellType {
  Code = "code",
  Heading = "heading",
  Markdown = "markdown",
}

export interface CellMetadata {}

export interface Output {
  output_type: string;
  prompt_number?: number;
  text: string[];
  stream?: string;
}
